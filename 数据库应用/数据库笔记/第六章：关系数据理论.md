# 关系数据理论 



## 问题的提出

关系数据库逻辑设计：

​	针对具体问题，如何构造一个适合于它的数据模式

​	数据库逻辑设计的工具──关系数据库的规范化理论

关系模式由五部分组成，是一个五元组：R(U, D, DOM, F)

​	关系名R是符号化的元组语义
​	U为一组属性
​	D为属性组U中的属性所来自的域
​	DOM为属性到域的映射
​	F为属性组U上的一组数据依赖

：由于D、DOM与模式设计关系不大，因此在本章中把关系模式看作一个三元组：R<U,F>

：当且仅当**U上的一个关系r**满足F时，r称为关系模式R<U,F>的一个关系

：作为二维表，关系要符合一个最基本的条件：每个分量必须是不可分开的数据项。满足了这个条件的关系模式就属于第一范式（1NF）	



数据依赖

是一个关系内部属性与属性之间的一种**约束关系**：通过**属性间值的相等**与否体现出来的数据间相互联系

是现实世界属性间相互联系的抽象

是数据内在的性质

是语义的体现



数据依赖的主要类型

**函数依赖**（Functional Dependency，简记为FD）

**多值依赖**（Multi-Valued Dependency，简记为MVD）



**函数依赖？**

Sname=f(Sno)，Sdept=f(Sno)
即Sno函数决定Sname，Sno函数决定Sdept
记作Sno→Sname，Sno→Sdept



关系模式Student<U, F>中存在的问题：

（1）数据冗余：浪费大量的存储空间。

（2）更新异常（Update Anomalies）：更新数据时，维护数据完整性代价大。

（3）==插入异常==（Insertion Anomalies）：如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。

（4）==删除异常==（Deletion Anomalies）：如果某个系的学生全部毕业了， 则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。（容易删多东西）

：一个“好”的模式应当不会发生插入异常、删除异常和更新异常，数据冗余应尽可能少。

原因：由存在于模式中的某些数据依赖引起的。

解决方法：用**规范化理论**改造关系模式来消除其中不合适的数据依赖



## 规范化

### 函数依赖

**定义**：设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。

函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的**所有关系**实例均要满足的约束条件

函数依赖是语义范畴的概念，只能根据数据的语义来确定一个函数依赖。

### 平凡函数依赖与非平凡函数依赖

X→Y，但Y⊈X则称X→Y是非平凡的函数依赖。
X→Y，但Y⊆X 则称X→Y是平凡的函数依赖。

对于任一关系模式，**平凡函数依赖都是必然成立**的，它不反映新的语义。
若不特别声明， 我们总是讨论非平凡函数依赖。

符号说明：
若X→Y，则X称为这个函数依赖的决定因素（Determinant）。
若X→Y，Y→X，则记作X←→Y。
若Y不函数依赖于X，则记作X↛Y。

完全函数依赖：（全部集齐才能召唤神龙！！）

在R(U)中，如果X→Y，并且对于X的任何一个真子集X’, 都有 X’ ↛ Y, 则称Y对X完全函数依赖，记作X F→ Y![image-20240228173925984](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228173925984.png)

部分函数依赖：

若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作X P→ Y![image-20240228173937254](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228173937254.png)

传递函数依赖：

在R(U)中，如果**X→Y(Y⊈X)，Y↛X**，Y→Z，Z⊈Y, 则称Z对X传递函数依赖(transitive functional dependency)。记为：X 传递→ Z。![image-20240228173825916](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228173825916.png)

注: 如果Y→X, 即X←→Y，则Z直接依赖于X，而不是传递函数依赖。



### 码

定义：设K为R<U,F>中的属性或属性组合。若K → U，则K称为R的一个候选码(Candidate Key)。

：如果U部分函数依赖于K，即K P→ U,则K称为超码（Surpkey）。候选码是**最小的超码**，即K的**任意一个真子集**都不是候选码。

若关系模式R有多个候选码，则选定其中的一个做为**主码(Primary key)**

主属性与非主属性

：包含在**任何一个候选码**中的属性 ，称为主属性 （Prime attribute） 

：不包含在**任何码**中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）

全码：整个属性组是码，称为全码（All-key） 

外码：关系模式 R中属性或属性组X 并非 R的码，但 X 是另一个关系模式的码，则称 X 是R 的外部码（Foreign key）也称外码。



### 范式

范式是**符合某一种级别的关系模式**的**集合**。

关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。

各种范式之间存在联系：

![image-20240228175119373](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228175119373.png)某一关系模式R为第n范式，可简记为R∈nNF。

**规范化**：一个低一级范式的关系模式，通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（normalization）。



### 2NF

若关系模式R∈1NF，并且每一个**非主属性**都**完全函数依赖**于任何一个候选码，则R∈2NF

一个关系模式不属于2NF，会产生以下问题：

插入异常：如果插入一个新学生，但该生未选课，即该生无Cno，由于插入元组时，必须给定码值，因此插入失败。

删除异常：如果S4只选了一门课C3，现在他不再选这门课，则删除C3后，整个元组的其他信息也被删除了。

修改复杂：如果一个学生选了多门课，则Sdept，Sloc被存储了多次。如果该生转系，则需要修改所有相关的Sdept和Sloc，造成修改的复杂化。

产生问题原因：

​	例子中有两类非主属性：一类如Grade，它对码完全函数依赖；另一类如Sdept、Sloc，它们对码不是完全函数依赖

解决方法：

​	用投影分解把关系模式S-L-C分解成两个关系模式（之前就是所有都在一起，现在两个表 ，多了一列sno）![image-20240228180210346](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228180210346.png)

从非主属性开始切割

### 3NF

定义：设关系模式R<U,F>∈**1NF,**若R中不存在这样的码X、属性组Y及非主属性Z（Z ⊇\ Y）, 使得X→Y，Y→Z成立，Y ↛ X不成立，则称R<U,F> ∈ 3NF。

（2-NF的基础上 没有传递依赖）

### ==BCNF==

：BCNF（Boyce Codd Normal Form）由Boyce和Codd提出，比3NF更进了一步。通常认为BCNF是修正的第三范式，有时也称为扩充的第三范式

定义：设关系模式R<U,F>∈1NF，若X →Y且Y /⊆ X时X必含有码，则R<U,F>∈BCNF。

:在关系模式R<U,F>中，如果每一个决定属性集都包含候选码，则R∈BCNF。(查看决定因素即可判断)

BCNF的关系模式所具有的性质:
所有**非主属性**都**完全**函数依赖于**每个候选码**
所有**主属性**都完全函数依赖于每个**不包含它的候选码**
**没有任何属性**完全函数依赖于**非码**的**任何一组属性**

地位：如果一个关系数据库中的所有关系模式都属于BCNF，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常。

### ==多值依赖==

定义一：设R(U)是属性集U上的一个关系模式。X,Y,Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X→→Y成立，当且仅当对R(U)的任一关系r，给定的一对(x,z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。

定义二：在R(U)的任一关系r中，如果存在元组t，s使得t[X]=s[X]，那么就必然存在元组w，v∈r，（w，v可以与s，t相同）, 使得w[X]=v[X]=t[X]，而w[Y]=t[Y]，w[Z]=s[Z]，v[Y]=s[Y]，v[Z]=t[Z]（即交换s，t元组的Y值所得的两
个新元组必在r中则Y多值依赖于X，记为X→→Y。这里X，Y是U的子集，Z=U-X-Y。

#### 平凡多值依赖和非平凡的多值依赖

​	平凡：若X→→Y，而Z＝Ф，即Z为空，则称X→→Y为平凡的多值依赖。
​	非平凡：否则称X→→Y为非平凡的多值依赖。

#### 多值依赖的性质

（1）多值依赖具有对称性：即若X→→Y，则X→→Z，其中Z＝U－X－Y

（2）多值依赖具有传递性：即若X→→Y，Y→→Z， 则X→→Z -Y。

（3）函数依赖是多值依赖的特殊情况。即若X→Y，则 X→→Y。

（4）若X→→Y，X→→Z，则X→→YZ。

（5）若X→→Y，X→→Z，则X→→Y∩Z。

（6）若X→→Y，X→→Z，则X→→Y-Z，X→→Z -Y。

#### 多值依赖与函数依赖的区别

（1）多值依赖的有效性与属性集的范围有关

![image-20240228193432622](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228193432622.png)



### ==4NF==

定义：关系模式R<U,F>∈1NF，如果对于R的每个非平凡多值依赖X→→Y（Y ⊈ X），X都含有码，则R<U,F>∈4NF。

：4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。4NF所允许的非平凡多值依赖实际上是函数依赖。

：如果一个关系模式是4NF， 则必为BCNF。



### 规范化小结

在关系数据库中，对关系模式的基本要求是满足第一范式。

规范化程度过低的关系不一定能够很好地描述现实世界

​	：可能存在插入异常、删除异常、修改复杂、数据冗余等问题
​	：解决方法就是对其进行规范化，转换成高级范式。

一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合，这种过程就叫关系模式的规范化

关系数据库的**规范化理论**是数据库**逻辑设计的工具**。

规范化的**基本思想**：

：是逐步消除数据依赖中不合适的部分，使模式中的各关系模式达到某种程度的“分离”。

：即采用“**一事一地**”的模式设计原则
	让一个关系描述一个概念、一个实体或者实体间的一种联系。
	若多于一个概念就把它“分离”出去。

：因此 规范化实质上是**概念的单一化**。

​	![image-20240228194323368](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228194323368.png)



### ==数据依赖的公理系统==

**逻辑蕴含**定义：对于满足一组**函数依赖F**的关系模式   R <U,F>，其任何一个关系r，若函数依赖X→Y都成立（即r中任意两元组t、s，若t[X]=s[X]，则 t[Y]=s[Y]），则称**F逻辑蕴涵X →Y**。

Armstrong公理系统

​	：一套推理规则，是模式分解算法的理论基础

用途
	：**求**给定关系模式的**码**
	：从一组函数依赖求得**蕴涵的函数依赖**





# 小结

![image-20240228195034745](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228195034745.png)



















