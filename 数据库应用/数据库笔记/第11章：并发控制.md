# 并发控制

多用户数据库系统

多事务执行方式 

（1）事务串行执行

（2）交叉并发方式（Interleaved  Concurrency）

（3）同时并发方式（simultaneous  concurrency）

事务并发执行带来的问题：

- 会产生多个事务同时存取同一数据的情况 
- 可能会存取和存储不正确的数据，破坏事务隔离性和数据库的一致性

数据库管理系统必须提供并发控制机制

并发控制机制是衡量一个数据库管理系统性能的重要标志之一

### 并发控制概述

事务是并发控制的基本单位

并发控制机制的任务

- 对并发操作进行正确调度

- 保证事务的隔离性

- 保证数据库的一致性

并发操作带来的数据**不一致性**

1. 丢失修改（Lost Update）

   ：两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。

2. 不可重复读（Non-repeatable Read）

   ：不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。（三种情况）

3. 读“脏”数据（Dirty Read）

记号

R(x):读数据x

W(x):写数据x 

###### 并发控制的主要技术

- **封锁(Locking)**
- 时间戳(Timestamp)
- 乐观控制法
- 多版本并发控制(MVCC)

#####  封锁

基本封锁类型：

- 排它锁（Exclusive Locks，简记为X锁）
- 共享锁（Share Locks，简记为S锁）

锁的相容矩阵：

![image-20240229234601822](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240229234601822.png)



#### 封锁协议

在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol）。 

- 何时申请X锁或S锁
- 持锁时间
- 何时释放

三级封锁协议

1. 一级封锁协议

   事务T在修改数据R之前必须先对其加X锁，直到**事务结束**才释放。

   - 正常结束（COMMIT）
   - 非正常结束（ROLLBACK）

   ：一级封锁协议可防止丢失修改，并保证事务T是可恢复的。

   ：在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。

2. 二级封锁协议

   一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。

   ：二级封锁协议可以防止丢失修改和读“脏”数据。

   ：在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。

3. 三级封锁协议

   一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。

   ：三级封锁协议可防止丢失修改、读脏数据和不可重复读。

4. 封锁协议级别越高，一致性程度越高

![image-20240229235311533](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240229235311533.png)

#### 活锁和死锁

活锁：有的事务活着，但是有事务要饿死了

避免活锁：采用先来先服务的策略

死锁：我在等你，你在等我！大家都死翘翘啦！

两类方法

 1. 死锁的预防（操作系统会用）：破坏死锁条件	

    （1）一次封锁法（全部加锁再执行）

    （2）顺序封锁法（形成一个DAG：就没有环啦！）

2. 死锁的诊断与解除（数据库系统会用）

   诊断：

   （1）超时法（事务等待超时！）

   （2）等待图法 （周期性检查回路法）

   ​	：事务是点，如果一个事务依赖另一个事务的资源，就向那个事务连边

   解除：

   选择一个处理死锁**代价最小**的事务，将其撤消

   释放此事务持有的所有的锁，使其它事务能继续运行下去



### 并发调度的可串行性

数据库管理系统对并发事务不同的调度可能会产生不同的结果

串行调度是正确的

执行**结果等价**于串行调度的调度也是正确的，称为**可串行化调度** 

#### 可串行化调度

可串行化(Serializable)调度：

- 多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同

可串行性(Serializability)：

- 是并发事务正确调度的准则

- 一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度 

冲突可串行化调度：

：一个比可串行化更严格的条件

：商用系统中的调度器采用

冲突操作：是指**不同的事务**对**同一数据**的**读写**操作和**写写**操作：

不能交换（Swap）的动作:

- 同一事务的两个操作
- 不同事务的冲突操作

：一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是冲突可串行化的调度

冲突可串行化调度是可串行化调度的**充分条件**，不是必要条件。

#### 两段锁协议

指所有事务必须分两个阶段对数据项加锁和解锁 （00001111）

- 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁
- 在释放一个封锁之后，事务不再申请和获得任何其他封锁

数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性 

- 事务遵守两段锁协议是可串行化调度的**充分条件**，而不是必要条件。
- 若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的
- 若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议



两段锁协议与防止死锁的一次封锁法：（根本就不是一个东西！）

后者是遵循两段锁的

两段锁也会死锁

### 封锁的粒度

封锁对象的大小称为封锁粒度(Granularity) 

封锁的对象:逻辑单元，物理单元 

逻辑单元: 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等
物理单元：页（数据页或索引页）、物理记录等

- 封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；
- 封锁的粒度越小，并发度较高，但系统开销也就越大

多粒度封锁(Multiple Granularity Locking)：在一个系统中同时支持多种封锁粒度供不同的事务选择

#### 多粒度封锁

多粒度树

- 以树形结构来表示多级封锁粒度
- 根结点是整个数据库，表示最大的数据粒度
- 叶结点表示最小的数据粒度

![image-20240301003633260](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240301003633260.png)

允许多粒度树中的每个结点被独立地加锁

对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁

在多粒度封锁中一个数据对象可能以两种方式封锁：**显式封锁**和**隐式封锁**

加锁时需要检查祖先节点，以及子树节点：看能不能相容

#### 意向锁

引进意向锁（intention lock）目的：提高对某个数据对象加锁时系统的检查效率

如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁

对任一结点加基本锁，必须先对它的（所有祖先）上层结点加意向锁

- 意向共享锁(Intent Share Lock，简称IS锁)
- 意向排它锁(Intent Exclusive Lock，简称IX锁)
- 共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)

![image-20240301004236613](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240301004236613.png)

![image-20240301004316245](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240301004316245.png)

==也许一个节点只能上一把锁？==

具有意向锁的多粒度封锁方法

- 申请封锁时应该按自上而下的次序进行
- 释放封锁时则应该按自下而上的次序进行

## 小结

数据库的并发控制以事务为单位

数据库的并发控制通常使用封锁机制

- 基本封锁

- 多粒度封锁

活锁和死锁

并发事务调度的正确性

- 可串行性
  - 并发操作的正确性则通常由两段锁协议来保证。
  - 两段锁协议是可串行化调度的充分条件，但不是必要条件
- 冲突可串行性

==其他并发控制机制==（暂时可以不用学）

- 时间戳方法
- 乐观控制法
- 多版本并发控制