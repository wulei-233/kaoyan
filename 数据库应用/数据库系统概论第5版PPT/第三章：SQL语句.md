## 关系数据库标准语言SQL

### SQL概述

SQL:结构化查询语言，是关系数据库的标准语言

**非关系数据模型**采用面向记录的操作方式，操作对象是一条记录

SQL采用集合操作方式:

​	 操作对象、查找结果可以是**元组的集合**
 	一次插入、删除、更新操作的对象可以是**元组的集合**

SQL是独立的语言,SQL又是嵌入式语言

![image-20240227200617420](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240227200617420.png)



SQL的三级结构：

![image-20240227200636729](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240227200636729.png)



基本表？

​	：本身独立存在的表
​	：SQL中一个关系就对应一个基本表
​	：一个（或多个）基本表对应一个存储文件
​	：一个表可以带若干索引

存储文件？

​	：逻辑结构组成了关系数据库的内模式
​	：物理结构对用户是隐蔽（透明）的

视图？

​	：从一个或几个基本表导出的表
​	：数据库中只存放视图的定义而不存放视图对应的数据
​	：视图是一个虚表
​	：用户可以在视图上再定义视图



### 数据定义

#### 模式定义

​	定义模式实际上定义了一个命名空间。

​	在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。

​	**创建模式：**在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。

```sql
CREATE SCHEMA <模式名> AUTHORIZATION <用户名>[<表定义子句>|<视图定义子句>|<授权定义子句>]
```

​	删除模式：

```sql
DROP SCHEMA <模式名> <CASCADE|RESTRICT>
```



​	CASCADE（级联）
​		：删除模式的同时把该模式中所有的数据库对象全部删除

​	RESTRICT（限制）
​		：如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。
​		：仅当该模式中没有任何下属的对象时才能执行

![image-20240227201341147](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240227201341147.png)



#### 基本表的定义、删除与修改

```sql
CREATE TABLE <表名>
      (<列名> <数据类型>[ <列级完整性约束条件> ]
      [,<列名> <数据类型>[ <列级完整性约束条件>] ] 
   …
      [,<表级完整性约束条件> ] );

<表名>：所要定义的基本表的名字
<列名>：组成该表的各个属性（列）
<列级完整性约束条件>：涉及相应属性列的完整性约束条件
<表级完整性约束条件>：涉及一个或多个属性列的完整性约束条件 
```

注：完整性约束条件涉及到该表的多个属性列，必须定义在表级上，否则既可以定义在列级也可以定义在表级。 

SQL中域的概念用数据类型来实现

定义表的属性时需要指明其数据类型及长度 

选用哪种数据类型 ：取值范围 ，要做哪些运算

##### 模式与表关系

​	：每一个基本表都属于某一个模式
​	：一个模式包含多个基本表
​	：定义基本表所属模式（三种方法：

```sql
在表名中明显地给出模式名 
Create table"S-T".Student(......); 
如果没给出 那就在默认路径中找（第一个模式）

在创建模式语句中同时创建表 
-略

设置所属的模式
-略
```

修改基本表：

```sql
ALTER TABLE <表名>
[ ADD[COLUMN] <新列名> <数据类型> [ 完整性约束 ] ]
[ ADD <表级完整性约束>]
[ DROP [ COLUMN ] <列名> [CASCADE| RESTRICT] ]
[ DROP CONSTRAINT<完整性约束名>[ RESTRICT | CASCADE ] ]
[ALTER COLUMN <列名><数据类型> ] ;

注：<表名>是要修改的基本表
ADD子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件
DROP COLUMN子句用于删除表中的列
如果指定了CASCADE短语，则自动删除引用了该列的其他对象
如果指定了RESTRICT短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列
DROP CONSTRAINT子句用于删除指定的完整性约束条件
ALTER COLUMN子句用于修改原有的列定义，包括修改列名和数据类型

```

删除基本表：

```sql
DROP TABLE <表名>［RESTRICT| CASCADE］;

CASCADE：删除该表没有限制。
在删除基本表的同时，相关的依赖对象一起删除 

CASCADE：删除该表没有限制。
在删除基本表的同时，相关的依赖对象一起删除 
```

#### 索引的建立与删除

索引：加快查找速度

常见索引：顺序，B+树，散列，位图；

特点：B+树索引具有动态平衡的优点 ，HASH索引具有查找速度快的特点

建立索引：数据库管理员 或 表的属主（即建立表的人）

```sql
CREATE [UNIQUE] [CLUSTER] INDEX <索引名> 
ON <表名>(<列名>[<次序>][,<列名>[<次序>] ]…);

注：
<表名>：要建索引的基本表的名字
索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔
<次序>：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC
UNIQUE：此索引的每一个索引值只对应唯一的数据记录
CLUSTER：表示要建立的索引是聚簇索引
```

修改索引：

```sql
ALTER INDEX <旧索引名> RENAME TO <新索引名>
```

删除索引：

```sql
DROP INDEX <索引名>;
```

维护索引：关系数据库管理系统**自动**完成

使用索引：关系数据库管理系统**自动**选择合适的索引作为存取路径，用户不必也不能显式地选择索引

#### 数据字典

数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有**定义信息**：

**关系模式**定义
**视图**定义
**索引**定义
**完整性约束**定义
各类**用户**对数据库的**操作权限**
**统计信息**等

：关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在**更新**数据字典表中的相应信息



### 数据查询

```sql
SELECT [ALL|DISTINCT] <目标列表达式>[,<目标列表达式>] …
       FROM <表名或视图名>[,<表名或视图名> ]…|(SELECT 语句)      
                   [AS]<别名>
[ WHERE <条件表达式> ]
[ GROUP BY <列名1> [ HAVING <条件表达式> ] ]
[ ORDER BY <列名2> [ ASC|DESC ] ];

注：
SELECT子句：指定要显示的属性列
FROM子句：指定查询对象（基本表或视图）
WHERE子句：指定查询条件
GROUP BY子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。
HAVING短语：只有满足指定条件的组才予以输出
ORDER BY子句：对查询结果表按指定列值的升序或降序排序 
```

注：*目标表达式？ 

单表查询：查询仅涉及一个表

1.选择表中的若干列： SELECT   属性   FROM   表
2.选择表中的若干元组：SELECT ALL / DISTINCT --- FROM ---  WHERE----- 
3.ORDER BY子句 ：WHERE---- ORDER BY Grade DESC;
4.==聚集函数==：COUNT(DISTINCT Sno)
5.GROUP BY子句：细化聚集函数的作用对象
	HAVING短语与WHERE子句的区别：
		作用对象不同
		WHERE子句作用于基表或视图，从中选择满足条件的元组
		HAVING短语作用于组，从中选择满足条件的组。

连接查询：同时涉及两个以上的表的查询

连接条件或连接谓词：用来连接两个表的条件

 ```sql
[<表名1>.]<列名1>  <比较运算符>  [<表名2>.]<列名2>

[<表名1>.]<列名1> BETWEEN [<表名2>.]<列名2> AND [<表名2>.]<列名3>
 ```

连接字段：连接谓词中的列名称：连接条件中的各连接字段类型必须是可比的，但名字不必相同

等值与非等值连接查询 ：

等值连接：连接运算符为=：WHERE  Student.Sno = SC.Sno;

自然连接：  WHERE  Student.Sno=SC.Sno  AND SC.Cno=' 2 ' AND SC.Grade>90; （先选择 后连接）

实现连接的方法：

（1）嵌套循环法（NESTED-LOOP）

（2）排序合并法（SORT-MERGE）（双指针）

（3）索引连接（INDEX-JOIN）（另一个表一个表简历快速查询的索引）

****

自身连接：一个表与其自己进行连接

​	需要给表起别名以示区别

​	由于所有属性名都是同名属性，因此必须使用别名前缀



外连接：

普通连接操作只输出满足连接条件的元组

外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出

左外连接（枚举左边 即使失配也要写上去）
列出左边关系中所有的元组 

右外连接（与上者相反）
列出右边关系中所有的元组



多表连接：两个以上的表进行连接（一次连接前两个，然后再重复以上）

WHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno;	



#### 嵌套查询

一个SELECT-FROM-WHERE语句称为一个查询块

将一个查询块嵌套在另一个查询块的**WHERE子句**或**HAVING短语**的条件中的查询称为嵌套查询

上层的查询块称为外层查询或父查询，下层查询块称为内层查询或子查询

SQL语言允许多层嵌套查询

子查询的限制：不能使用ORDER BY子句

**不相关子查询**：子查询的查询条件不依赖于父查询

：**由里向外** 逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。

**相关子查询**：子查询的查询条件依赖于父查询（的某个属性）

：首先取外层查询中表的**第一个元组**，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表：然后再取外层表的下一个元组：重复这一过程，直至外层表全部检查完为止

#####   1.带有IN谓词的子查询 

：在不在IN后面SELECT出来的子集中

##### 2.带有比较运算符的子查询

：返回的是一个值！（聚集函数，属性值）

：IN可以用=替代

##### 3.带有ANY（SOME）或ALL谓词的子查询

：使用ANY或ALL谓词时必须同时使用比较运算

\> ANY 大于子查询结果中的某个值

\> ALL 大于子查询结果中的所有值

：WHERE Sage < ANY (...）形成条件

：某些时候等价于 运算符+min/max

##### 4.带有EXISTS谓词的子查询

：存在量词 （反E）看子查询的集合是否为空

：NOT EXISTS

：一些带EXISTS或NOT EXISTS谓词的子查询不能被其他形式的子查询等价替换

：所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换

：用EXISTS/NOT EXISTS实现全称量词（难点）

![image-20240228100049628](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228100049628.png)

：用EXISTS/NOT EXISTS实现逻辑蕴涵（难点）

![image-20240228100039204](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228100039204.png)



#### 集合查询

集合操作的种类

1.并操作UNION

```sql
 SELECT Sno
        FROM SC
        WHERE Cno=' 1 '
        UNION
        SELECT Sno
        FROM SC
        WHERE Cno= ' 2 ';
查询选修了课程1或者选修了课程2的学生。
```

2.交操作INTERSECT

```sql
SELECT Sno
    FROM SC
    WHERE Cno=' 1 ' 
    INTERSECT
    SELECT Sno
    FROM SC
    WHERE Cno='2 ';
查询既选修了课程1又选修了课程2的学生。
```

3.差操作EXCEPT

```sql
SELECT *
    FROM Student
    WHERE Sdept='CS'
    EXCEPT
    SELECT  *
    FROM Student
    WHERE Sage <=19;
查询计算机科学系的学生与年龄不大于19岁的学生的差集。
```

：参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同 （元组一致性）

UNION：将多个查询结果合并起来时，系统自动去掉重复元组
UNION ALL：将多个查询结果合并起来时，保留重复元组



#### 基于派生表的查询	

子查询不仅可以出现在**WHERE子句**中，还可以出现在**FROM子句**中，这时子查询生成的临时派生表（Derived Table）成为主查询的查询对象

```sql
SELECT Sno, Cno
    FROM SC, (SELECTSno, Avg(Grade) 
                        FROM SC
    			  GROUP BY Sno)
                        AS   Avg_sc(avg_sno,avg_grade)
    WHERE SC.Sno = Avg_sc.avg_sno
      and SC.Grade >=Avg_sc.avg_grade
找出每个学生超过他自己选修课程平均成绩的课程号
```

如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列名为其缺省属性。

```sql
SELECT Sname
    FROM     Student,  
                   (SELECT Sno FROM SC WHERE Cno=' 1 ') AS SC1
    WHERE  Student.Sno=SC1.Sno;
查询所有选修了1号课程的学生姓名
```

#### SELECT语句的一般形式	

```sql
SELECT [ALL|DISTINCT]  
   <目标列表达式> [别名] [ ,<目标列表达式> [别名]] …
 FROM     <表名或视图名> [别名] 
                [ ,<表名或视图名> [别名]] …
                |(<SELECT语句>)[AS]<别名>
 [WHERE <条件表达式>]
 [GROUP BY <列名1>[HAVING<条件表达式>]]
 [ORDER BY <列名2> [ASC|DESC]];
```

##### 目标列表达式格式

（1） *
（2） <表名>.*
（3） COUNT([DISTINCT|ALL]* )
（4） [<表名>.]<属性列名表达式>[,<表名>.]<属性列名表达式>]…

其中<属性列名表达式>可以是由属性列、作用于属性列的聚集函数和常量的任意算术运算（+，-，*，/）组成的运算公式 

##### 聚集函数的一般格式

#####  WHERE子句的条件表达式的可选格式

##### WHERE子句的条件表达式格式



### 数据更新

#### 插入数据

插入元组，或，插入子查询结果(可以一次插入多个元组)

##### 插入元组

```sql
INSERT
	INTO <表名> [(<属性列1>[,<属性列2 >…)]
	VALUES (<常量1> [,<常量2>]… );
将新元组插入指定表中
```

 INTO子句

指定要插入数据的表名及属性列
属性列的顺序可与表定义中的顺序不一致
没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致
指定部分属性列：插入的元组在其余属性列上取空值

VALUES子句

提供的值必须与INTO子句匹配
值的个数
值的类型

```sql
INSERT
    INTO  Student (Sno,Sname,Ssex,Sdept,Sage)
    VALUES ('201215128','陈冬','男','IS',18);
将一个新学生元组（学号：201215128;姓名：陈冬;性别：男;所在系：IS;年龄：18岁）插入到Student表中
```

##### 插入子查询结果