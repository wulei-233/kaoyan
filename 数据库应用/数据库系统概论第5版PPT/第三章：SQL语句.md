## 关系数据库标准语言SQL

### SQL概述

SQL:结构化查询语言，是关系数据库的标准语言

**非关系数据模型**采用面向记录的操作方式，操作对象是一条记录

SQL采用集合操作方式:

​	 操作对象、查找结果可以是**元组的集合**
 	一次插入、删除、更新操作的对象可以是**元组的集合**

SQL是独立的语言,SQL又是嵌入式语言

![image-20240227200617420](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240227200617420.png)



SQL的三级结构：

![image-20240227200636729](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240227200636729.png)



基本表？

​	：本身独立存在的表
​	：SQL中一个关系就对应一个基本表
​	：一个（或多个）基本表对应一个存储文件
​	：一个表可以带若干索引

存储文件？

​	：逻辑结构组成了关系数据库的内模式
​	：物理结构对用户是隐蔽（透明）的

视图？

​	：从一个或几个基本表导出的表
​	：数据库中只存放视图的定义而不存放视图对应的数据
​	：视图是一个虚表
​	：用户可以在视图上再定义视图



### 数据定义

#### 模式定义

​	定义模式实际上定义了一个命名空间。

​	在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。

​	**创建模式：**在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。

```sql
CREATE SCHEMA <模式名> AUTHORIZATION <用户名>[<表定义子句>|<视图定义子句>|<授权定义子句>]
```

​	删除模式：

```sql
DROP SCHEMA <模式名> <CASCADE|RESTRICT>
```



​	CASCADE（级联）
​		：删除模式的同时把该模式中所有的数据库对象全部删除

​	RESTRICT（限制）
​		：如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。
​		：仅当该模式中没有任何下属的对象时才能执行

![image-20240227201341147](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240227201341147.png)



#### 基本表的定义、删除与修改

```sql
CREATE TABLE <表名>
      (<列名> <数据类型>[ <列级完整性约束条件> ]
      [,<列名> <数据类型>[ <列级完整性约束条件>] ] 
   …
      [,<表级完整性约束条件> ] );

<表名>：所要定义的基本表的名字
<列名>：组成该表的各个属性（列）
<列级完整性约束条件>：涉及相应属性列的完整性约束条件
<表级完整性约束条件>：涉及一个或多个属性列的完整性约束条件 
```

注：完整性约束条件涉及到该表的多个属性列，必须定义在表级上，否则既可以定义在列级也可以定义在表级。 

SQL中域的概念用数据类型来实现

定义表的属性时需要指明其数据类型及长度 

选用哪种数据类型 ：取值范围 ，要做哪些运算

##### 模式与表关系

​	：每一个基本表都属于某一个模式
​	：一个模式包含多个基本表
​	：定义基本表所属模式（三种方法：

```sql
在表名中明显地给出模式名 
Create table"S-T".Student(......); 
如果没给出 那就在默认路径中找（第一个模式）

在创建模式语句中同时创建表 
-略

设置所属的模式
-略
```

修改基本表：

```sql
ALTER TABLE <表名>
[ ADD[COLUMN] <新列名> <数据类型> [ 完整性约束 ] ]
[ ADD <表级完整性约束>]
[ DROP [ COLUMN ] <列名> [CASCADE| RESTRICT] ]
[ DROP CONSTRAINT<完整性约束名>[ RESTRICT | CASCADE ] ]
[ALTER COLUMN <列名><数据类型> ] ;

注：<表名>是要修改的基本表
ADD子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件
DROP COLUMN子句用于删除表中的列
如果指定了CASCADE短语，则自动删除引用了该列的其他对象
如果指定了RESTRICT短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列
DROP CONSTRAINT子句用于删除指定的完整性约束条件
ALTER COLUMN子句用于修改原有的列定义，包括修改列名和数据类型

```

删除基本表：

```sql
DROP TABLE <表名>［RESTRICT| CASCADE］;

CASCADE：删除该表没有限制。
在删除基本表的同时，相关的依赖对象一起删除 

CASCADE：删除该表没有限制。
在删除基本表的同时，相关的依赖对象一起删除 
```

#### 索引的建立与删除

索引：加快查找速度

常见索引：顺序，B+树，散列，位图；

特点：B+树索引具有动态平衡的优点 ，HASH索引具有查找速度快的特点

建立索引：数据库管理员 或 表的属主（即建立表的人）

```sql
CREATE [UNIQUE] [CLUSTER] INDEX <索引名> 
ON <表名>(<列名>[<次序>][,<列名>[<次序>] ]…);

注：
<表名>：要建索引的基本表的名字
索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔
<次序>：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC
UNIQUE：此索引的每一个索引值只对应唯一的数据记录
CLUSTER：表示要建立的索引是聚簇索引
```

修改索引：

```sql
ALTER INDEX <旧索引名> RENAME TO <新索引名>
```

删除索引：

```sql
DROP INDEX <索引名>;
```

维护索引：关系数据库管理系统**自动**完成

使用索引：关系数据库管理系统**自动**选择合适的索引作为存取路径，用户不必也不能显式地选择索引

#### 数据字典

数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有**定义信息**：

**关系模式**定义
**视图**定义
**索引**定义
**完整性约束**定义
各类**用户**对数据库的**操作权限**
**统计信息**等

：关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在**更新**数据字典表中的相应信息



### 数据查询

```sql
SELECT [ALL|DISTINCT] <目标列表达式>[,<目标列表达式>] …
       FROM <表名或视图名>[,<表名或视图名> ]…|(SELECT 语句)      
                   [AS]<别名>
[ WHERE <条件表达式> ]
[ GROUP BY <列名1> [ HAVING <条件表达式> ] ]
[ ORDER BY <列名2> [ ASC|DESC ] ];

注：
SELECT子句：指定要显示的属性列
FROM子句：指定查询对象（基本表或视图）
WHERE子句：指定查询条件
GROUP BY子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。
HAVING短语：只有满足指定条件的组才予以输出
ORDER BY子句：对查询结果表按指定列值的升序或降序排序 
```

注：*目标表达式？ 

单表查询：查询仅涉及一个表

1.选择表中的若干列： SELECT   属性   FROM   表
2.选择表中的若干元组：SELECT ALL / DISTINCT --- FROM ---  WHERE----- 
3.ORDER BY子句 ：WHERE---- ORDER BY Grade DESC;
4.==聚集函数==：COUNT(DISTINCT Sno)
5.GROUP BY子句：细化聚集函数的作用对象
	HAVING短语与WHERE子句的区别：
		作用对象不同
		WHERE子句作用于基表或视图，从中选择满足条件的元组
		HAVING短语作用于组，从中选择满足条件的组。

连接查询：同时涉及两个以上的表的查询

连接条件或连接谓词：用来连接两个表的条件

 ```sql
[<表名1>.]<列名1>  <比较运算符>  [<表名2>.]<列名2>

[<表名1>.]<列名1> BETWEEN [<表名2>.]<列名2> AND [<表名2>.]<列名3>
 ```

连接字段：连接谓词中的列名称：连接条件中的各连接字段类型必须是可比的，但名字不必相同

等值与非等值连接查询 ：

等值连接：连接运算符为=：WHERE  Student.Sno = SC.Sno;

自然连接：  WHERE  Student.Sno=SC.Sno  AND SC.Cno=' 2 ' AND SC.Grade>90; （先选择 后连接）

实现连接的方法：

（1）嵌套循环法（NESTED-LOOP）

（2）排序合并法（SORT-MERGE）（双指针）

（3）索引连接（INDEX-JOIN）（另一个表一个表简历快速查询的索引）

****

自身连接：一个表与其自己进行连接

​	需要给表起别名以示区别

​	由于所有属性名都是同名属性，因此必须使用别名前缀



外连接：

普通连接操作只输出满足连接条件的元组

外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出

左外连接（枚举左边 即使失配也要写上去）
列出左边关系中所有的元组 

右外连接（与上者相反）
列出右边关系中所有的元组



多表连接：两个以上的表进行连接（一次连接前两个，然后再重复以上）

WHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno;	



#### 嵌套查询

一个SELECT-FROM-WHERE语句称为一个查询块

将一个查询块嵌套在另一个查询块的**WHERE子句**或**HAVING短语**的条件中的查询称为嵌套查询

上层的查询块称为外层查询或父查询，下层查询块称为内层查询或子查询

SQL语言允许多层嵌套查询

子查询的限制：不能使用ORDER BY子句

**不相关子查询**：子查询的查询条件不依赖于父查询

：**由里向外** 逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。

**相关子查询**：子查询的查询条件依赖于父查询（的某个属性）

：首先取外层查询中表的**第一个元组**，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表：然后再取外层表的下一个元组：重复这一过程，直至外层表全部检查完为止

#####   1.带有IN谓词的子查询 

：在不在IN后面SELECT出来的子集中

##### 2.带有比较运算符的子查询

：返回的是一个值！（聚集函数，属性值）

：IN可以用=替代

##### 3.带有ANY（SOME）或ALL谓词的子查询

：使用ANY或ALL谓词时必须同时使用比较运算

\> ANY 大于子查询结果中的某个值

\> ALL 大于子查询结果中的所有值

：WHERE Sage < ANY (...）形成条件

：某些时候等价于 运算符+min/max

##### 4.带有EXISTS谓词的子查询

：存在量词 （反E）看子查询的集合是否为空

：NOT EXISTS

：一些带EXISTS或NOT EXISTS谓词的子查询不能被其他形式的子查询等价替换

：所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换

：用EXISTS/NOT EXISTS实现全称量词（难点）

![image-20240228100049628](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228100049628.png)

：用EXISTS/NOT EXISTS实现逻辑蕴涵（难点）

![image-20240228100039204](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228100039204.png)



#### 集合查询

集合操作的种类

1.并操作UNION

```sql
 SELECT Sno
        FROM SC
        WHERE Cno=' 1 '
        UNION
        SELECT Sno
        FROM SC
        WHERE Cno= ' 2 ';
查询选修了课程1或者选修了课程2的学生。
```

2.交操作INTERSECT

```sql
SELECT Sno
    FROM SC
    WHERE Cno=' 1 ' 
    INTERSECT
    SELECT Sno
    FROM SC
    WHERE Cno='2 ';
查询既选修了课程1又选修了课程2的学生。
```

3.差操作EXCEPT

```sql
SELECT *
    FROM Student
    WHERE Sdept='CS'
    EXCEPT
    SELECT  *
    FROM Student
    WHERE Sage <=19;
查询计算机科学系的学生与年龄不大于19岁的学生的差集。
```

：参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同 （元组一致性）

UNION：将多个查询结果合并起来时，系统自动去掉重复元组
UNION ALL：将多个查询结果合并起来时，保留重复元组



#### 基于派生表的查询	

子查询不仅可以出现在**WHERE子句**中，还可以出现在**FROM子句**中，这时子查询生成的临时派生表（Derived Table）成为主查询的查询对象

```sql
SELECT Sno, Cno
    FROM SC, (SELECTSno, Avg(Grade) 
                        FROM SC
    			  GROUP BY Sno)
                        AS   Avg_sc(avg_sno,avg_grade)
    WHERE SC.Sno = Avg_sc.avg_sno
      and SC.Grade >=Avg_sc.avg_grade
找出每个学生超过他自己选修课程平均成绩的课程号
```

如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列名为其缺省属性。

```sql
SELECT Sname
    FROM     Student,  
                   (SELECT Sno FROM SC WHERE Cno=' 1 ') AS SC1
    WHERE  Student.Sno=SC1.Sno;
查询所有选修了1号课程的学生姓名
```

#### SELECT语句的一般形式	

```sql
SELECT [ALL|DISTINCT]  
   <目标列表达式> [别名] [ ,<目标列表达式> [别名]] …
 FROM     <表名或视图名> [别名] 
                [ ,<表名或视图名> [别名]] …
                |(<SELECT语句>)[AS]<别名>
 [WHERE <条件表达式>]
 [GROUP BY <列名1>[HAVING<条件表达式>]]
 [ORDER BY <列名2> [ASC|DESC]];
```

##### 目标列表达式格式

（1） *
（2） <表名>.*
（3） COUNT([DISTINCT|ALL]* )
（4） [<表名>.]<属性列名表达式>[,<表名>.]<属性列名表达式>]…

其中<属性列名表达式>可以是由属性列、作用于属性列的聚集函数和常量的任意算术运算（+，-，*，/）组成的运算公式 

##### 聚集函数的一般格式

#####  WHERE子句的条件表达式的可选格式

##### WHERE子句的条件表达式格式



### 数据更新

#### 插入数据

插入元组，或，插入子查询结果(可以一次插入多个元组)

##### 插入元组

```sql
INSERT
	INTO <表名> [(<属性列1>[,<属性列2 >…)]
	VALUES (<常量1> [,<常量2>]… );
将新元组插入指定表中
```

 INTO子句

指定要插入数据的表名及属性列
属性列的顺序可与表定义中的顺序不一致
没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致
指定部分属性列：插入的元组在其余属性列上取空值

VALUES子句

提供的值必须与INTO子句匹配
值的个数
值的类型

```sql
INSERT
    INTO  Student (Sno,Sname,Ssex,Sdept,Sage)
    VALUES ('201215128','陈冬','男','IS',18);
将一个新学生元组（学号：201215128;姓名：陈冬;性别：男;所在系：IS;年龄：18岁）插入到Student表中
```

##### 插入子查询结果

```sql
INSERT 
     INTO <表名>  [(<属性列1> [,<属性列2>…  )]
 	子查询;
```

```sql
[例3.72]  对每一个系，求学生的平均年龄，并把结果存入数据库
第一步：建表
      CREATE  TABLE  Dept_age
          ( Sdept     CHAR(15)                     /*系名*/
            Avg_age SMALLINT);          	/*学生平均年龄*/
第二步：插入数据
        INSERT
       INTO  Dept_age(Sdept,Avg_age)
              SELECT  Sdept，AVG(Sage)
              FROM     Student
              GROUP BY Sdept;

```

关系数据库管理系统在执行插入语句时会检查所插元组是否破坏表上已定义的**完整性规则**



#### 修改数据

```sql
UPDATE  <表名>
    SET  <列名>=<表达式>[,<列名>=<表达式>]…
    [WHERE <条件>];
```

：修改指定表中满足WHERE子句条件的元组
：SET子句给出<表达式>的值用于取代相应的属性列
：如果省略WHERE子句，表示要修改表中的所有元组

三种修改方式
修改某一个元组的值
修改多个元组的值
带子查询的修改语句

关系数据库管理系统在执行修改语句时会检查修改操作是否破坏表上已定义的**完整性规则**



#### 删除数据

```sql
DELETE
       FROM     <表名>
       [WHERE <条件>];

删除指定表中满足WHERE子句条件的元组

WHERE子句
指定要删除的元组
缺省表示要删除表中的全部元组，表的定义仍在字典中
```

三种删除方式
删除某一个元组的值
删除多个元组的值
带子查询的删除语句



### 空值的处理

空值就是“不知道”或“不存在”或“无意义”的值

一般有以下几种情况：
1.该属性应该有一个值，但目前不知道它的具体值
2.该属性不应该有值
3.由于某种原因不便于填写

空值是一个很特殊的值，含有不确定性。对**关系运算**带来特殊的问题，需要做特殊的处理。

判断一个属性的值是否为空值，用IS NULL或IS NOT NULL来表示

空值的算术运算、比较运算和逻辑运算:

​	空值与另一个值（包括另一个空值）的算术运算的结果为空值
​	空值与另一个值（包括另一个空值）的比较运算的结果为UNKNOWN。
​	有UNKNOWN后，传统二值（TRUE，FALSE）逻辑就扩展成了三值逻辑

![image-20240228123611658](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228123611658.png)



### 视图

视图的特点:

​	**虚表**，是从一个或几个基本表（或视图）**导出的表**
​	**只存**放视图的**定义**，**不存**放视图对应的**数据**
​	**基表**中的数据发生**变**化，从**视图**中查询出的数据也随之改**变**

##### 定义视图

###### 	建立视图

```sql
CREATE  VIEW 
             <视图名>  [(<列名>  [,<列名>]…)]
       AS  <子查询>
       [WITH  CHECK  OPTION]; 

```

对视图进行UPDATE，INSERT和DELETE操作时要保证更新、插入或删除的行满足**视图定义中的谓词条件**（即子查询中的条件表达式）

子查询可以是任意的SELECT语句，是否可以含有ORDER BY子句和DISTINCT短语，则决定具体系统的实现。

组成视图的属性列名：全部省略，或，全部指定

关系数据库管理系统执行CREATE VIEW语句时只是把视图**定义存入数据字典**，并**不执行其中的SELECT**语句。

在对视图查询时，按视图的定义从基本表中将数据查出。

例如：

```sql
CREATE VIEW IS_Student
        AS 
        SELECT Sno,Sname,Sage
        FROM     Student
        WHERE  Sdept= 'IS';
        [ WITH CHECK OPTION;] // 之后的插入修改都必须满足WHERE条件
建立信息系学生的视图。
注：定义IS_Student视图时加上了WITH CHECK OPTION子句，对该视图进行插入、修改和删除操作时，
	RDBMS会自动加上Sdept='IS'的条件。
```

若一个视图是从**单个基本表**导出的，并且只是去掉了基本表的某些行和某些列，但**保留了主码**，我们称这类视图为**行列子集视图**。（如上）

**基于多个基表的视图：**

```sql
[例3.86]  建立信息系选修了1号课程的学生的视图（包括学号、姓名、成绩）。
CREATE VIEW IS_S1(Sno,Sname,Grade)
        AS 
        SELECT Student.Sno,Sname,Grade
        FROM  Student,SC
        WHERE  Sdept= 'IS' AND
                       Student.Sno=SC.Sno AND
                       SC.Cno= '1';
```

**基于视图的视图:**

```sql
[例3.87]  建立信息系选修了1号课程且成绩在90分以上的学生的视图。
        CREATE VIEW IS_S2
        AS
        SELECT Sno,Sname,Grade
        FROM  IS_S1
        WHERE  Grade>=90;

```

**带表达式的视图**

```sql
[例3.88]  定义一个反映学生出生年份的视图。
        CREATE  VIEW BT_S(Sno,Sname,Sbirth)
        AS 
        SELECT Sno,Sname,2014-Sage
        FROM  Student;

```

**分组视图**

```sql
[例3.89]  将学生的学号及平均成绩定义为一个视图
	       CREAT  VIEW S_G(Sno,Gavg)
             AS  
             SELECT Sno,AVG(Grade)
             FROM  SC
             GROUP BY Sno;

```



###### 	**删除视图**

```sql
DROP  VIEW  <视图名>[CASCADE];
该语句从数据字典中删除指定的视图定义
如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除 
删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除 

  [例3.91 ] 删除视图BT_S和IS_S1
		DROP VIEW BT_S;	/*成功执行*/
		DROP VIEW IS_S1;	/*拒绝执行*/
	      
           要删除IS_S1，需使用级联删除：
           DROP VIEW IS_S1 CASCADE;  
```



##### 查询视图

用户角度：查询视图与查询基本表相同

关系数据库管理系统实现视图查询的方法:

1.视图消解法（View Resolution）
	：进行有效性检查
	：转换成等价的对基本表的查询
	：执行修正后的查询

​	视图消解法的局限：有些情况下，视图消解法不能生成正确的查询。



##### 更新视图

本质：转化成对应基本表的更新

更新视图的限制：一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新

：允许对**行列子集视图**进行更新

：对其他类型视图的更新不同系统有不同限制

DB2对视图更新的限制：
若视图是由两个以上基本表导出的，则此视图不允许更新。
若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。
若视图的字段来自集函数，则此视图不允许更新。
若视图定义中含有GROUP BY子句，则此视图不允许更新。
若视图定义中含有DISTINCT短语，则此视图不允许更新。
若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。

一个不允许更新的视图上定义的视图也不允许更新。



##### 视图的作用

理解：：：：：：

视图能够简化用户的操作
视图使用户能以多种角度看待同一数据 
视图对重构数据库提供了一定程度的逻辑独立性 
视图能够对机密数据提供安全保护
适当的利用视图可以更清晰的表达查询



### 小结

![image-20240228131750848](C:\Users\10263\AppData\Roaming\Typora\typora-user-images\image-20240228131750848.png)